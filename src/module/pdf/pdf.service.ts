import { Injectable, Logger } from '@nestjs/common';
import * as PDFDocument from 'pdfkit';
import { CreatePdfDto } from './dto/create-pdf.dto';
import { PdfResponseDto } from './dto/pdf-response.dto';

@Injectable()
export class PdfService {
  private readonly logger = new Logger(PdfService.name);

  async createPdfFromText(createPdfDto: CreatePdfDto): Promise<PdfResponseDto> {
    try {
      this.logger.log('Creating PDF from text', {
        textLength: createPdfDto.text.length,
        title: createPdfDto.title,
      });

      const doc = new PDFDocument({
        size: 'A4',
        margins: {
          top: 50,
          bottom: 50,
          left: 50,
          right: 50,
        },
        info: {
          Title: createPdfDto.title || 'Generated PDF',
          Author: createPdfDto.author || 'PDF Service',
          Subject: createPdfDto.subject || 'Generated Document',
          CreationDate: new Date(),
        },
      });

      const chunks: Buffer[] = [];

      // Collect PDF data chunks
      doc.on('data', (chunk: Buffer) => {
        chunks.push(chunk);
      });

      // Set font and size
      doc
        .font(createPdfDto.fontFamily || 'Helvetica')
        .fontSize(createPdfDto.fontSize || 12);

      // Add header if requested
      if (createPdfDto.includeHeader && createPdfDto.title) {
        this.addHeader(doc, createPdfDto.title);
      }

      // Add main content
      this.addContent(doc, createPdfDto.text);

      // Add footer if requested
      if (createPdfDto.includeFooter) {
        this.addFooter(doc, createPdfDto.author);
      }

      // Add page numbers if requested
      if (createPdfDto.includePageNumbers) {
        this.addPageNumbers(doc);
      }

      // Finalize the PDF
      doc.end();

      // Wait for the PDF to be generated
      return new Promise((resolve, reject) => {
        doc.on('end', () => {
          try {
            const pdfBuffer = Buffer.concat(chunks);
            const pdfBase64 = pdfBuffer.toString('base64');

            this.logger.log('PDF created successfully', {
              fileSize: pdfBuffer.length,
              pageCount: doc.bufferedPageRange().count,
            });

            const response: PdfResponseDto = {
              success: true,
              message: 'PDF created successfully',
              pdfBase64,
              fileSize: pdfBuffer.length,
              pageCount: doc.bufferedPageRange().count,
            };

            resolve(response);
          } catch (error) {
            this.logger.error('Error processing PDF buffer', error);
            reject(error instanceof Error ? error : new Error(String(error)));
          }
        });

        doc.on('error', (error) => {
          this.logger.error('Error generating PDF', error);
          reject(error instanceof Error ? error : new Error(String(error)));
        });
      });
    } catch (error) {
      this.logger.error('Error creating PDF from text', error);

      return {
        success: false,
        message: 'Failed to create PDF',
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  private addHeader(doc: PDFKit.PDFDocument, title: string): void {
    const originalFontSize = 12; // Default font size

    doc
      .fontSize(16)
      .font('Helvetica-Bold')
      .text(title, { align: 'center' })
      .moveDown(0.5)
      .fontSize(originalFontSize)
      .font('Helvetica');
  }

  private addContent(doc: PDFKit.PDFDocument, text: string): void {
    // Split text into paragraphs and add them
    const paragraphs = text.split('\n\n');

    paragraphs.forEach((paragraph, index) => {
      if (paragraph.trim()) {
        doc.text(paragraph.trim());

        // Add space between paragraphs, but not after the last one
        if (index < paragraphs.length - 1) {
          doc.moveDown(0.5);
        }
      }
    });
  }

  private addFooter(doc: PDFKit.PDFDocument, author?: string): void {
    // Add footer to current page only - will be applied to all pages
    const footerText = author
      ? `Generated by ${author} on ${new Date().toLocaleDateString()}`
      : `Generated on ${new Date().toLocaleDateString()}`;

    doc.fontSize(8).text(footerText, 50, doc.page.height - 50, {
      align: 'center',
      width: doc.page.width - 100,
    });
  }

  private addPageNumbers(doc: PDFKit.PDFDocument): void {
    // Add page number to current page only - will be applied to all pages
    doc.fontSize(10).text(`Page 1`, 0, doc.page.height - 30, {
      align: 'center',
      width: doc.page.width,
    });
  }

  getPdfInfo(pdfBuffer: Buffer): {
    pageCount: number;
    fileSize: number;
    isValid: boolean;
  } {
    try {
      // Basic validation - check if it's a valid PDF by looking for PDF header
      const header = pdfBuffer.toString('ascii', 0, 4);
      const isValid = header === '%PDF';

      // For a more complete implementation, you might want to use a library like pdf-parse
      // to get actual page count and other metadata

      return {
        pageCount: 0, // Would need pdf-parse or similar to get actual count
        fileSize: pdfBuffer.length,
        isValid,
      };
    } catch (error) {
      this.logger.error('Error getting PDF info', error);
      return {
        pageCount: 0,
        fileSize: 0,
        isValid: false,
      };
    }
  }
}
